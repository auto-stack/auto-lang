/// Auto Flow - Iterator and Functional Programming System (Plan 051)
/// This module provides zero-cost iterator abstractions for AutoLang

/// Core iterator spec - produces values of type T
spec Iter<T> {
    /// Try to get the next value
    /// Returns nil when iteration is complete
    fn next() May<T>

    // --- Lazy adapters ---

    /// Transform each element using function f
    /// Returns a new iterator that maps each element
    fn map<U>(f: fn(T)U) MapIter<Self, T, U>

    /// Filter elements by predicate p
    /// Returns a new iterator with only matching elements
    fn filter(p: fn(T)bool) FilterIter<Self, T>

    // --- Terminal operators ---

    /// Fold/reduce: consume iterator, accumulating values
    fn reduce<B>(init: B, f: fn(B, T)B) B

    /// Count elements in iterator
    fn count() u32

    /// Call function f for each element
    fn for_each(f: fn(T)void) void

    /// Collect all elements into a collection
    fn collect() List<T, Heap>

    /// Check if any element satisfies predicate
    fn any(p: fn(T)bool) bool

    /// Check if all elements satisfy predicate
    fn all(p: fn(T)bool) bool

    /// Find first element matching predicate
    fn find(p: fn(T)bool) May<T>
}

/// Type that can be iterated over
/// Simplified approach: no associated types, just return Iter<T>
spec Iterable<T> {
    /// Get an iterator for this collection
    fn iter() Iter<T>
}

/// Type that can collect from an iterator
/// This allows different collection strategies (List, Array, etc.)
spec Collect<T> {
    /// Collect iterator elements into this collection type
    fn from_iter(iter: Iter<T>) Self
}
