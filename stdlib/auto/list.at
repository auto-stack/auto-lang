/// Storage-agnostic dynamic list (Vec-like) for storing elements
/// Uses pluggable storage strategies via the Storage<T> spec
/// Plan 052: Storage-based list implementation
///
/// LIMITATIONS (to be addressed in future plans):
/// - Trait bounds (S: Storage<T>) require Plan 058
/// - Generic ext blocks require parser enhancement
/// - For now, methods use VM/C implementations directly

type List<T, S> {
    // Number of elements currently in the list
    len u32

    // Storage backend (Heap<T>, Inline<T, N>, etc.)
    // Must implement Storage<T> spec
    store S

    // ========================================================================
    // Static Methods - Creation
    // ========================================================================

    /// Create a new empty List with the given storage strategy
    /// Example: List<int, Heap>.new()
    #[c, vm, pub]
    static fn new() List<T, S>

    // ========================================================================
    // Instance Methods - Access
    // ========================================================================

    /// Get the number of elements in the list
    /// Example: list.len()
    #[c, vm, pub]
    fn len() int

    /// Check if the list is empty
    /// Example: list.is_empty()
    #[c, vm, pub]
    fn is_empty() bool

    /// Get the total capacity (from storage)
    /// Example: list.capacity()
    #[c, vm, pub]
    fn capacity() int

    /// Get element at index (bounds checking required)
    /// Example: list.get(0)
    #[c, vm, pub]
    fn get(index int) T

    // ========================================================================
    // Instance Methods - Modification
    // ========================================================================

    /// Push element to the end (grows storage if needed)
    /// Example: list.push(item)
    #[c, vm, pub]
    fn push(elem T)

    /// Pop element from the end
    /// Example: list.pop()
    #[c, vm, pub]
    fn pop() T

    /// Set element at index
    /// Example: list.set(0, item)
    #[c, vm, pub]
    fn set(index int, elem T) int

    /// Remove all elements (keeps capacity)
    /// Example: list.clear()
    #[c, vm, pub]
    fn clear()

    // ========================================================================
    // Instance Methods - Lifecycle
    // ========================================================================

    /// Free the list's resources (drops storage)
    /// Example: list.drop()
    #[c, vm, pub]
    fn drop()
}
