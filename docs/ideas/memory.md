## Auto语言内存管理


## 静态与动态

考虑到Auto语言的主要应用场景是嵌入式开发，因此在语言设计时，应当把静态内存管理上升到和动态内存相同的地位。

需求列表：

1. 语言与标准库支持静态内存分配模式。甚至支持动静态分配可选模式。
2. 动静态内存的分配与回收在语言层面提供同级别的支持。
3. 内存分配需要考虑到线程自有内存（ThreadLocal Mem）和任务自有内存（TaskLocal Mem）。
4. 内存的释放机制应当尽量做到自动化。如果无法自动释放，应当提供编译器级别的检测功能。
5. 寿元管理。设计一套比Rust更简单的生命周期管理机制。

## 寿元管理

### 寿元级别

1. 长生不老：Immortal。程序结束后，仍然续存。一般需要配合NVM等持续化技术使用。
2. 寿与天齐：Process。程序结束时，随之结束。普通的全局变量一般属于这个范畴。
3. 六道轮回：Auto(GC/RC)。不受Scope约束，而以内生的“寿命”决定生死。往往可以跨域函数的藩篱。
4. 浮生若梦：Task。任务完成时结束。
5. 缘起缘灭：Start/Stop。比任务级稍短，需要手动调用Stop这类函数来终结。
6. 白驹过隙：Period。例如游戏编程中的一帧。
3. 朝生暮死：Scope。当前Scope结束时，随之结束。生死周期往往是一个函数，甚至一段代码块。
4. 瞬息蜉蝣：Instant。产生，使用，释放。生死之间的距离是语句级别。

TODO: RAII类型的元寿需要单独管理吗？

### 寿元标注

全局变量默认是`Process`级别的，而局部变量默认是`Scope`级别的。
如果我们要给某个元数标记其他级别的寿元。就需要使用寿元标注了。
