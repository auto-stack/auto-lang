这是一份根据最新审美调整后的 **Auto 语言 (.at)** 核心语法介绍文档。

我们将所有的后置操作（无论是符号还是单词）统一收纳在点号 `.` 之下。这种设计让点号成为了 `.at` 语言中唯一的**“属性引导符”**，视觉上达到了极度的工整与统一，同时也强化了“一切皆属性”的哲学。

---

# Auto 语言核心规范：统一属性化设计

在 **Auto 语言 (.at)** 中，我们消除了一切前缀操作符和嵌套括号。通过统一的**点号引导符（Dot-notated Lead）**，我们将内存契约、解构操作和类型转换全部转化为从左向右的线性流。

其核心哲学是：**每一个点号，都是对数据的一次深度加工或权限切换。**

---

## 1. 语法分类：属性符号 vs 属性关键字

所有的后置操作现在都遵循统一的格式：`Object.Property`。

### A. 属性符号 (Symbol Properties)

用简洁的符号代表最基础的物理或底层操作。

* **`.?`** ：解包（Option/Result 类型安全解包）。
* **`.*`** ：解引用（访问指针指向的目标空间）。
* **`.@`** ：取地址（获取当前目标的内存坐标）。

### B. 属性关键字 (Keyword Properties)

用语义化的单词描述高级的逻辑契约、权限或转换。

* **`.view` / `.mut` / `.take**` ：所有权与权限切换。
* **`.as` / `.to**` ：类型转换（如 `500.as.u64`）。
* **`.fixed` / `.dynamic**` ：缓冲区模式适配。

---

## 2. 视觉一致性与空格规范

统一使用点号后，代码展现出一种工业级的工整感。为了区分逻辑运算与属性访问，编译器强制执行以下规则：

* **属性流**：点号两侧严禁空格（如 `p.*`），代表紧密的级联关系。
* **二元运算**：运算符两侧必须有空格（如 `a * b`），代表独立的数学逻辑。

---

## 3. 从简单到复杂的示例演进

### 示例 1：基础指针与类型转换

点号引导让原本需要括号的优先级问题消失，代码读起来像一条直线。

```rust
fn demo_basic() {
    let n i32 = 100
    let ptr = n.@          // 获取地址：主体.地址
    
    // 线性流：指针.取值 -> 结果.转为f32 -> 数学运算
    let val = ptr.*.as.f32 * 1.5
    
    print(val)
}

```

### 示例 2：空安全与属性访问

使用 `.?` 代替复杂的 `unwrap` 或 `if let`，保持链条不断裂。

```rust
type Student {
    name str
    age  i32
}

fn get_student_age(y ?Student) i32 {
    // 逻辑：y 如果有值，则取其 age；否则返回 0
    // 注意：.? 也是点号引导的一环
    return y.?.age ?? 0
}

```

### 示例 3：复杂的内存契约级联

这是 `.at` 语言最具代表性的写法，展示了权限切换与物理操作的无缝串联。

```rust
[pub, async]
fn process_sensor(y ?Sensor) {
    // 纯线性阅读路径：
    // 1. y.?      -> 解包传感器
    // 2. .mut    -> 切换到可变权限
    // 3. .buffer -> 访问缓冲区成员
    // 4. .@      -> 获取缓冲区地址
    // 5. .* -> 访问地址指向的内容
    let data = y.?.mut.buffer.@.*
    
    print("Data: " + data.to.str)
}

```

### 示例 4：终极场景（泛型、数组与适配器）

展示如何用一套 API 通过 `.fixed` 和 `.dynamic` 适配不同的硬件平台。

```rust
// 统一的写入接口
fn log_data<T>(mut w Writer, val T) {
    w.mut.append("Val: ")
    w.mut.append(val.to.str)
}

fn main() {
    // PC 场景：String 会动态扩容
    let out String = ""
    log_data(out.mut.dynamic, 404)

    // MCU 场景：固定长度数组，零分配
    let [mut, shared] buf [32]u8 = [0; 32]
    log_data(buf.mut.fixed, 200)
    
    // 即使再复杂的类型，读取逻辑依然清晰
    // 解包 -> 只读视图 -> 获取长度 -> 强制转为 u64
    let count = out.?.view.len.as.u64
}

```

---

## 4. 为什么“统一加点”是更好的设计？

1. **心智模型简化**：开发者只需要记住“我想对这个东西做什么，就打一个点”。
2. **IDE 补全友好**：当你输入 `.` 后，AutoIDE 可以列出所有可能的符号（`?`, `*`, `@`）和关键字，不需要切换思维。
3. **语法扩展性**：如果未来需要增加新的操作（如异步等待 `.await` 或解包 `.opt`），它们都能完美融入现有的点号体系中，不会破坏语言的整体感。
4. **工整美学**：取消了 `y?` 这种“吊在后面”的碎片感，让所有操作符都整齐地挂在点号轴线上。

---